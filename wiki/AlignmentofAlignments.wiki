#summary Details of how to align two alignments.

= Introduction =

Alignment of two alignments, each containing internal gaps, is more complex than aligning two sequences.

== Considerations ==

  * Sum-of-pairs score: the score of an alignment is the sum of the pairwise alignment scores between each pair of sequences in the alignment.
  * "Once a gap, always a gap": internal gaps within the two input alignments are unchanged in the output alignment.
  * The following situation is treated as a single gap for scoring purposes:

{{{
XX--XXXX
XXXX--XX
}}}

= Details =

The problem of aligning two alignments optimally is NP-hard.  Therefore we will not do that.  But what we *can* do is ensure that the alignment score from our dynamic programming algorithm is the correct sum-of-pairs score for the resulting alignment.  So the score will be correct, even if it is not optimal.  This commitment to computing the correct score gives us some advantages:
  # The steps where heuristics are applied can be more obvious, and hopefully more encapsulated, than if we produced an approximately correct score.
  # The correct score permits sharper testing and debugging.

== How do we produce this correct sum-of-pairs score? ==

... by ensuring that our pairwise alignment scores, gap extension scores, and gap opening scores are each computed correctly during the dynamic programming recurrence.  The gap opening score will turn out to be the tricky one.  So lets handle gap opening first, to get it out of the way.

=== Gap opening score ===

This first example shows a single column indel between two alignments.  
  * '-' represents a preexisting gap
  * 'i' represents a new insertion gap
  * 'X' represents a non-gap residue
  * '{{{*}}}' highlights the column(s) where the main action occurs

{{{
 alignment 1 (sequences a-d):
     * 
a) XXiX
b) XXi-
c) X-iX
d) X-i-
     * 

 alignment 2 (sequences e-l):
     * 
e) XXXX
f) XXX-
g) X-XX
h) X-X-
i) XX-X
j) XX--
k) X--X
l) X---
     * 
}}}

Consider each of the individual pairwise sequence alignments:

  * '+' shows where a new gap opening score should be applied at the (2,3) position in the recurrence algorithm.
  * '0' shows where a new gap opening score is unnecessary because there is no (net) gap.
  * '1' shows where a new gap opening score is unnecessary because the gap opening score would have already been assessed before position (2,3).
  * '2' shows where a gap opening score will be assessed *later* in the recurrence.

{{{
    a    b    c    d

  XXiX XXi- X-iX X-i-
e XXXX XXXX XXXX XXXX
    +    +    1    1 

  XXiX XXi- X-iX X-i-
f XXX- XXX- XXX- XXX-
    +    +    1    1 

  XXiX XXi- X-iX X-i-
g X-XX X-XX X-XX X-XX
    1    1    +<   +< 

  XXiX XXi- X-iX X-i-
h X-X- X-X- X-X- X-X-
    1    1    +<   +<

  XXiX XXi- X-iX X-i-
i XX-X XX-X XX-X XX-X
    0>   2>   1    1 

  XXiX XXi- X-iX X-i-
j XX-- XX-- XX-- XX--
    2>   0>   1    1 

  XXiX XXi- X-iX X-i-
k X--X X--X X--X X--X
    1    1    0>   2>

  XXiX XXi- X-iX X-i-
l X--- X--- X--- X---
    1    1    2>   0>
}}}

Basically, a gap open score is assessed any time there is an alignment like
{{{
XX
X-
 *
}}}
or
{{{
X-X
X--
  *
}}}
or
{{{
X-----X
X------
      *
}}}
etc.

Algorithmic intuition suggests that we do not want to be looking back arbitrarily far to determine whether a situation like this is occurring.  But maybe we can track a parameter describing "number of positions since the previous non-gap character" during the recurrence.  For each sequence.  For each recurrence type.  Ouch.  The alignment time is probably going to technically be O(k*m*n) anyway, and I doubt this approach will exceed that.  But we want to keep that k out of there as much as possible.  So let's try clustering and compressing the sequence distance to previous non-gap information, in a manner analogous to the EString representation of gapping pattern.  For each input sequence 1, 2, and each recurrence state V, G, E, F, store a sorted vector of <distance, sequence count> pairs describing the distance to the previous non-gap.  
// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_moltk.h"
#include "Aligner.pypp.hpp"

namespace bp = boost::python;

struct Aligner_wrapper : moltk::Aligner, bp::wrapper< moltk::Aligner > {

    Aligner_wrapper(moltk::Aligner const & arg )
    : moltk::Aligner( arg )
      , bp::wrapper< moltk::Aligner >(){
        // copy constructor
        
    }

    struct QueryPosition_wrapper : moltk::Aligner::QueryPosition, bp::wrapper< moltk::Aligner::QueryPosition > {
    
        QueryPosition_wrapper()
        : moltk::Aligner::QueryPosition()
          , bp::wrapper< moltk::Aligner::QueryPosition >(){
            // null constructor
            
        }
    
        virtual ::moltk::Aligner::QueryPosition * clone(  ) const {
            bp::override func_clone = this->get_override( "clone" );
            return func_clone(  );
        }
    
        virtual ::moltk::units::Information gapExtensionPenalty(  ) const {
            bp::override func_gapExtensionPenalty = this->get_override( "gapExtensionPenalty" );
            return func_gapExtensionPenalty(  );
        }
    
        virtual ::moltk::units::Information gapOpenPenalty(  ) const {
            bp::override func_gapOpenPenalty = this->get_override( "gapOpenPenalty" );
            return func_gapOpenPenalty(  );
        }
    
    };

    struct Scorer_wrapper : moltk::Aligner::Scorer, bp::wrapper< moltk::Aligner::Scorer > {
    
        Scorer_wrapper( )
        : moltk::Aligner::Scorer( )
          , bp::wrapper< moltk::Aligner::Scorer >(){
            // null constructor
        
        }
    
        virtual ::std::vector< moltk::Aligner::QueryPosition* > createQueryPositions( ::moltk::Alignment const & arg0 ) const {
            bp::override func_createQueryPositions = this->get_override( "createQueryPositions" );
            return func_createQueryPositions( boost::ref(arg0) );
        }
    
        virtual ::std::vector< moltk::Aligner::TargetPosition* > createTargetPositions( ::moltk::Alignment const & arg0 ) const {
            bp::override func_createTargetPositions = this->get_override( "createTargetPositions" );
            return func_createTargetPositions( boost::ref(arg0) );
        }
    
    };

    struct TargetPosition_wrapper : moltk::Aligner::TargetPosition, bp::wrapper< moltk::Aligner::TargetPosition > {
    
        TargetPosition_wrapper()
        : moltk::Aligner::TargetPosition()
          , bp::wrapper< moltk::Aligner::TargetPosition >(){
            // null constructor
            
        }
    
        virtual ::moltk::Aligner::TargetPosition * clone(  ) const {
            bp::override func_clone = this->get_override( "clone" );
            return func_clone(  );
        }
    
        virtual ::moltk::units::Information gapExtensionPenalty(  ) const {
            bp::override func_gapExtensionPenalty = this->get_override( "gapExtensionPenalty" );
            return func_gapExtensionPenalty(  );
        }
    
        virtual ::moltk::units::Information gapOpenPenalty(  ) const {
            bp::override func_gapOpenPenalty = this->get_override( "gapOpenPenalty" );
            return func_gapOpenPenalty(  );
        }
    
        virtual ::moltk::units::Information score( ::moltk::Aligner::QueryPosition const & rhs ) const {
            bp::override func_score = this->get_override( "score" );
            return func_score( boost::ref(rhs) );
        }
    
    };

    Aligner_wrapper( )
    : moltk::Aligner( )
      , bp::wrapper< moltk::Aligner >(){
        // null constructor
    
    }

};

void register_Aligner_class(){

    { //::moltk::Aligner
        typedef bp::class_< Aligner_wrapper > Aligner_exposer_t;
        Aligner_exposer_t Aligner_exposer = Aligner_exposer_t( "Aligner", "\n Aligner is the class that creates sequence or structure alignments.\n", bp::init< >() );
        bp::scope Aligner_scope( Aligner_exposer );
        bp::enum_< moltk::Aligner::Stage>("Stage")
            .value("EMPTY_STAGE", moltk::Aligner::EMPTY_STAGE)
            .value("SCORER_STAGE", moltk::Aligner::SCORER_STAGE)
            .value("SEQUENCE_STAGE", moltk::Aligner::SEQUENCE_STAGE)
            .value("ALLOCATED_STAGE", moltk::Aligner::ALLOCATED_STAGE)
            .value("TABLE_INITIALIZED_STAGE", moltk::Aligner::TABLE_INITIALIZED_STAGE)
            .value("RECURRENCE_COMPUTED_STAGE", moltk::Aligner::RECURRENCE_COMPUTED_STAGE)
            .value("TRACED_STAGE", moltk::Aligner::TRACED_STAGE)
            .export_values()
            ;
        bp::enum_< moltk::Aligner::TracebackPointer>("TracebackPointer")
            .value("TRACEBACK_UP", moltk::Aligner::TRACEBACK_UP)
            .value("TRACEBACK_UPLEFT", moltk::Aligner::TRACEBACK_UPLEFT)
            .value("TRACEBACK_LEFT", moltk::Aligner::TRACEBACK_LEFT)
            .value("TRACEBACK_DONE", moltk::Aligner::TRACEBACK_DONE)
            .value("TRACEBACK_NOT_INITIALIZED", moltk::Aligner::TRACEBACK_NOT_INITIALIZED)
            .export_values()
            ;
        bp::class_< moltk::Aligner::Cell >( "Cell", " An Aligner::Cell is one node in the dynamic programming table" )    
            .def( 
                "compute_traceback_pointer"
                , (::moltk::Aligner::TracebackPointer ( ::moltk::Aligner::Cell::* )(  ) const)( &::moltk::Aligner::Cell::compute_traceback_pointer )
                , " An Aligner::Cell is one node in the dynamic programming table" )    
            .def( 
                "compute_v"
                , (::moltk::units::Information ( ::moltk::Aligner::Cell::* )(  ) const)( &::moltk::Aligner::Cell::compute_v ) )    
            .def_readwrite( "e", &moltk::Aligner::Cell::e, " E, best score with gap in sequence 1" )    
            .def_readwrite( "f", &moltk::Aligner::Cell::f, " F, best score with gap in sequence 2" )    
            .def_readwrite( "g", &moltk::Aligner::Cell::g, " G, best ungapped score through this cell" )    
            .def_readwrite( "v", &moltk::Aligner::Cell::v, " V, best score through this cell" )    
            .def( bp::self_ns::str( bp::self ) );
        bp::class_< Aligner_wrapper::QueryPosition_wrapper, boost::noncopyable >( "QueryPosition", "\n Aligner::Position represents a special biosequence residue that knows how to score itself during alignment.\n" )    
            .def( 
                "clone"
                , bp::pure_virtual( (::moltk::Aligner::QueryPosition * ( ::moltk::Aligner::QueryPosition::* )(  ) const)(&::moltk::Aligner::QueryPosition::clone) )
                , bp::return_value_policy< bp::manage_new_object >()
                , "\n Aligner::Position represents a special biosequence residue that knows how to score itself during alignment.\n" )    
            .def( 
                "gapExtensionPenalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::QueryPosition::* )(  ) const)(&::moltk::Aligner::QueryPosition::gapExtensionPenalty) ) )    
            .def( 
                "gapOpenPenalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::QueryPosition::* )(  ) const)(&::moltk::Aligner::QueryPosition::gapOpenPenalty) ) );
        bp::class_< Aligner_wrapper::Scorer_wrapper, boost::noncopyable >( "Scorer", "\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n", bp::init< >("\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n") )    
            .def( 
                "createQueryPositions"
                , bp::pure_virtual( (::std::vector< moltk::Aligner::QueryPosition* > ( ::moltk::Aligner::Scorer::* )( ::moltk::Alignment const & ) const)(&::moltk::Aligner::Scorer::createQueryPositions) )
                , ( bp::arg("arg0") )
                , "\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n" )    
            .def( 
                "createTargetPositions"
                , bp::pure_virtual( (::std::vector< moltk::Aligner::TargetPosition* > ( ::moltk::Aligner::Scorer::* )( ::moltk::Alignment const & ) const)(&::moltk::Aligner::Scorer::createTargetPositions) )
                , ( bp::arg("arg0") ) )    
            .def( 
                "getEndGapsFree"
                , (bool ( ::moltk::Aligner::Scorer::* )(  ) const)( &::moltk::Aligner::Scorer::getEndGapsFree ) )    
            .def( 
                "setEndGapsFree"
                , (void ( ::moltk::Aligner::Scorer::* )( bool ) )( &::moltk::Aligner::Scorer::setEndGapsFree )
                , ( bp::arg("f") ) );
        bp::class_< Aligner_wrapper::TargetPosition_wrapper, boost::noncopyable >( "TargetPosition" )    
            .def( 
                "clone"
                , bp::pure_virtual( (::moltk::Aligner::TargetPosition * ( ::moltk::Aligner::TargetPosition::* )(  ) const)(&::moltk::Aligner::TargetPosition::clone) )
                , bp::return_value_policy< bp::manage_new_object >() )    
            .def( 
                "gapExtensionPenalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::TargetPosition::* )(  ) const)(&::moltk::Aligner::TargetPosition::gapExtensionPenalty) ) )    
            .def( 
                "gapOpenPenalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::TargetPosition::* )(  ) const)(&::moltk::Aligner::TargetPosition::gapOpenPenalty) ) )    
            .def( 
                "score"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::TargetPosition::* )( ::moltk::Aligner::QueryPosition const & ) const)(&::moltk::Aligner::TargetPosition::score) )
                , ( bp::arg("rhs") ) );
        { //::moltk::Aligner::align
        
            typedef ::moltk::Alignment ( ::moltk::Aligner::*align_function_type )( ::moltk::Alignment const &,::moltk::Alignment const & ) ;
            
            Aligner_exposer.def( 
                "align"
                , align_function_type( &::moltk::Aligner::align )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::moltk::Aligner::getDefaultScorer
        
            typedef ::moltk::Aligner::Scorer const & ( *getDefaultScorer_function_type )(  );
            
            Aligner_exposer.def( 
                "getDefaultScorer"
                , getDefaultScorer_function_type( &::moltk::Aligner::getDefaultScorer )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::moltk::Aligner::getEndGapsFree
        
            typedef bool ( ::moltk::Aligner::*getEndGapsFree_function_type )(  ) const;
            
            Aligner_exposer.def( 
                "getEndGapsFree"
                , getEndGapsFree_function_type( &::moltk::Aligner::getEndGapsFree ) );
        
        }
        { //::moltk::Aligner::setEndGapsFree
        
            typedef void ( ::moltk::Aligner::*setEndGapsFree_function_type )( bool ) ;
            
            Aligner_exposer.def( 
                "setEndGapsFree"
                , setEndGapsFree_function_type( &::moltk::Aligner::setEndGapsFree )
                , ( bp::arg("f") ) );
        
        }
        Aligner_exposer.staticmethod( "getDefaultScorer" );
        { //property "endGapsFree"[fget=::moltk::Aligner::getEndGapsFree, fset=::moltk::Aligner::setEndGapsFree]
        
            typedef bool ( ::moltk::Aligner::*fget )(  ) const;
            typedef void ( ::moltk::Aligner::*fset )( bool ) ;
            
            Aligner_exposer.add_property( 
                "endGapsFree"
                , fget( &::moltk::Aligner::getEndGapsFree )
                , fset( &::moltk::Aligner::setEndGapsFree ) );
        
        }
    }

}

// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_moltk.hpp"
#include "length.pypp.hpp"

namespace bp = boost::python;

void register_Length_class(){

    { //::moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double >
        typedef bp::class_< moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double > > Length_exposer_t;
        Length_exposer_t Length_exposer = Length_exposer_t( "Length", "\n For efficiency, Quantity<> should compile to a double in C++.\n This means:\n     no virtual methods\n     no data members other than value\n     unit is a class with a typedef\n These restrictions need not apply to unit class, which should do\n whatever it needs to, to be wrapped conveniently in python.\n", bp::init< >() );
        bp::scope Length_scope( Length_exposer );
        Length_exposer.def( bp::init< double const &, moltk::units::Unit< moltk::units::LengthDimension > const & >(( bp::arg("v"), bp::arg("u") )) );
        Length_exposer.def( bp::init< moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double > const & >(( bp::arg("rhs") )) );
        Length_exposer.def( bp::self != bp::self );
        Length_exposer.def( bp::self * bp::other< moltk::Real >() );
        Length_exposer.def( bp::self *= bp::other< moltk::Real >() );
        Length_exposer.def( +bp::self );
        Length_exposer.def( +bp::self );
        Length_exposer.def( bp::self + bp::self );
        Length_exposer.def( bp::self += bp::self );
        Length_exposer.def( -bp::self );
        Length_exposer.def( bp::self - bp::self );
        Length_exposer.def( bp::self -= bp::self );
        Length_exposer.def( bp::self / bp::other< moltk::Real >() );
        Length_exposer.def( bp::self / bp::other< moltk::units::Unit< moltk::units::LengthDimension > >() );
        Length_exposer.def( bp::self / bp::self );
        Length_exposer.def( bp::self /= bp::other< moltk::Real >() );
        Length_exposer.def( bp::self < bp::self );
        Length_exposer.def( bp::self <= bp::self );
        { //::moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double >::operator=
        
            typedef moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double > exported_class_t;
            typedef ::moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double > & ( exported_class_t::*assign_function_type )( ::moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double > const & ) ;
            
            Length_exposer.def( 
                "assign"
                , assign_function_type( &::moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double >::operator= )
                , ( bp::arg("rhs") )
                , bp::return_self< >() );
        
        }
        Length_exposer.def( bp::self == bp::self );
        Length_exposer.def( bp::self > bp::self );
        Length_exposer.def( bp::self >= bp::self );
        Length_exposer.def_readwrite( "value", &moltk::units::Quantity< moltk::units::Unit< moltk::units::LengthDimension >, double >::value );
        Length_exposer.def( bp::other< moltk::Real >() * bp::self );
        Length_exposer.def( bp::self_ns::str( bp::self ) );
    }

}

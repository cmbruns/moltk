// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_moltk.h"
#include "aligner.pypp.hpp"

namespace bp = boost::python;

struct Aligner_wrapper : moltk::Aligner, bp::wrapper< moltk::Aligner > {

    Aligner_wrapper(moltk::Aligner const & arg )
    : moltk::Aligner( arg )
      , bp::wrapper< moltk::Aligner >(){
        // copy constructor
        
    }

    struct Position_wrapper : moltk::Aligner::Position, bp::wrapper< moltk::Aligner::Position > {
    
        Position_wrapper()
        : moltk::Aligner::Position()
          , bp::wrapper< moltk::Aligner::Position >(){
            // null constructor
            
        }
    
        virtual ::moltk::Aligner::Position * clone(  ) const {
            bp::override func_clone = this->get_override( "clone" );
            return func_clone(  );
        }
    
        virtual char getOneLetterCode(  ) const {
            bp::override func_getOneLetterCode = this->get_override( "getOneLetterCode" );
            return func_getOneLetterCode(  );
        }
    
        virtual ::moltk::units::Information score( ::moltk::Aligner::Position const & rhs ) const {
            bp::override func_score = this->get_override( "score" );
            return func_score( boost::ref(rhs) );
        }
    
    };

    struct Scorer_wrapper : moltk::Aligner::Scorer, bp::wrapper< moltk::Aligner::Scorer > {
    
        Scorer_wrapper()
        : moltk::Aligner::Scorer()
          , bp::wrapper< moltk::Aligner::Scorer >(){
            // null constructor
            
        }
    
        virtual ::moltk::Aligner::Position * createPosition( char sequenceLetter ) const {
            bp::override func_createPosition = this->get_override( "createPosition" );
            return func_createPosition( sequenceLetter );
        }
    
    };

    Aligner_wrapper( )
    : moltk::Aligner( )
      , bp::wrapper< moltk::Aligner >(){
        // null constructor
    
    }

};

void register_Aligner_class(){

    { //::moltk::Aligner
        typedef bp::class_< Aligner_wrapper > Aligner_exposer_t;
        Aligner_exposer_t Aligner_exposer = Aligner_exposer_t( "Aligner", "\n Aligner is the class that creates sequence or structure alignments.\n", bp::init< >() );
        bp::scope Aligner_scope( Aligner_exposer );
        bp::enum_< moltk::Aligner::Stage>("Stage")
            .value("EMPTY_STAGE", moltk::Aligner::EMPTY_STAGE)
            .value("SCORER_STAGE", moltk::Aligner::SCORER_STAGE)
            .value("SEQUENCE_STAGE", moltk::Aligner::SEQUENCE_STAGE)
            .value("ALLOCATED_STAGE", moltk::Aligner::ALLOCATED_STAGE)
            .value("TABLE_INITIALIZED_STAGE", moltk::Aligner::TABLE_INITIALIZED_STAGE)
            .value("RECURRENCE_COMPUTED_STAGE", moltk::Aligner::RECURRENCE_COMPUTED_STAGE)
            .value("TRACED_STAGE", moltk::Aligner::TRACED_STAGE)
            .export_values()
            ;
        bp::enum_< moltk::Aligner::TracebackPointer>("TracebackPointer")
            .value("TRACEBACK_UP", moltk::Aligner::TRACEBACK_UP)
            .value("TRACEBACK_UPLEFT", moltk::Aligner::TRACEBACK_UPLEFT)
            .value("TRACEBACK_LEFT", moltk::Aligner::TRACEBACK_LEFT)
            .value("TRACEBACK_DONE", moltk::Aligner::TRACEBACK_DONE)
            .value("TRACEBACK_NOT_INITIALIZED", moltk::Aligner::TRACEBACK_NOT_INITIALIZED)
            .export_values()
            ;
        bp::class_< moltk::Aligner::Cell >( "Cell", "\n An Aligner::Cell is one node in the dynamic programming table\n" )    
            .def_readwrite( "e", &moltk::Aligner::Cell::e, "\n E, best score with gap in sequence 1\n" )    
            .def_readwrite( "f", &moltk::Aligner::Cell::f, "\n F, best score with gap in sequence 2\n" )    
            .def_readwrite( "g", &moltk::Aligner::Cell::g, "\n G, best ungapped score through this cell\n" )    
            .def_readwrite( "s", &moltk::Aligner::Cell::s, "\n Wm, score of aligning position S1(i) with S2(j)\n s is the score of aligning position S1(i) with S2(j); (Wm in Gusfields nomenclature.)\n" )    
            .def_readwrite( "tracebackPointer", &moltk::Aligner::Cell::tracebackPointer, "\n breadcrumb to help reconstruct the final alignment\n" )    
            .def_readwrite( "v", &moltk::Aligner::Cell::v, "\n V, best score through this cell\n" );
        bp::class_< Aligner_wrapper::Position_wrapper, boost::noncopyable >( "Position", "\n Aligner::Position represents a special biosequence residue that knows how to score itself during alignment.\n" )    
            .def( 
                "clone"
                , bp::pure_virtual( (::moltk::Aligner::Position * ( ::moltk::Aligner::Position::* )(  ) const)(&::moltk::Aligner::Position::clone) )
                , bp::return_value_policy< bp::manage_new_object >()
                , "\n Aligner::Position represents a special biosequence residue that knows how to score itself during alignment.\n" )    
            .def( 
                "getOneLetterCode"
                , bp::pure_virtual( (char ( ::moltk::Aligner::Position::* )(  ) const)(&::moltk::Aligner::Position::getOneLetterCode) ) )    
            .def( 
                "score"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::Position::* )( ::moltk::Aligner::Position const & ) const)(&::moltk::Aligner::Position::score) )
                , ( bp::arg("rhs") ) );
        { //::moltk::Aligner::PositionList
            typedef bp::class_< moltk::Aligner::PositionList > PositionList_exposer_t;
            PositionList_exposer_t PositionList_exposer = PositionList_exposer_t( "PositionList", "\n Aligner::PositionList is a special sequence containing Aligner::Positions,\n which know how to score themselves.\n", bp::init< >("\n Aligner::PositionList is a special sequence containing Aligner::Positions,\n which know how to score themselves.\n") );
            bp::scope PositionList_scope( PositionList_exposer );
            PositionList_exposer.def( bp::init< moltk::Aligner::PositionList const & >(( bp::arg("rhs") ), "\n Aligner::PositionList is a special sequence containing Aligner::Positions,\n which know how to score themselves.\n") );
            { //::moltk::Aligner::PositionList::operator=
            
                typedef ::moltk::Aligner::PositionList & ( ::moltk::Aligner::PositionList::*assign_function_type )( ::moltk::Aligner::PositionList const & ) ;
                
                PositionList_exposer.def( 
                    "assign"
                    , assign_function_type( &::moltk::Aligner::PositionList::operator= )
                    , ( bp::arg("rhs") )
                    , bp::return_self< >() );
            
            }
        }
        bp::class_< Aligner_wrapper::Scorer_wrapper, boost::noncopyable >( "Scorer", "\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n" )    
            .def( 
                "createPosition"
                , bp::pure_virtual( (::moltk::Aligner::Position * ( ::moltk::Aligner::Scorer::* )( char ) const)(&::moltk::Aligner::Scorer::createPosition) )
                , ( bp::arg("sequenceLetter") )
                , bp::return_value_policy< bp::manage_new_object >()
                , "\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n" );
        { //::moltk::Aligner::align
        
            typedef ::moltk::Alignment ( ::moltk::Aligner::*align_function_type )( ::moltk::FastaSequence const &,::moltk::FastaSequence const & ) ;
            
            Aligner_exposer.def( 
                "align"
                , align_function_type( &::moltk::Aligner::align )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::moltk::Aligner::getDefaultScorer
        
            typedef ::moltk::Aligner::Scorer const & ( *getDefaultScorer_function_type )(  );
            
            Aligner_exposer.def( 
                "getDefaultScorer"
                , getDefaultScorer_function_type( &::moltk::Aligner::getDefaultScorer )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        Aligner_exposer.staticmethod( "getDefaultScorer" );
    }

}

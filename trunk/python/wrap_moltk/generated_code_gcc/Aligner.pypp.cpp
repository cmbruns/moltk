// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_moltk.hpp"
#include "Aligner.pypp.hpp"

namespace bp = boost::python;

struct Aligner_wrapper : moltk::Aligner, bp::wrapper< moltk::Aligner > {

    Aligner_wrapper(moltk::Aligner const & arg )
    : moltk::Aligner( arg )
      , bp::wrapper< moltk::Aligner >(){
        // copy constructor
        
    }

    struct QueryPosition_wrapper : moltk::Aligner::QueryPosition, bp::wrapper< moltk::Aligner::QueryPosition > {
    
        QueryPosition_wrapper()
        : moltk::Aligner::QueryPosition()
          , bp::wrapper< moltk::Aligner::QueryPosition >(){
            // null constructor
            
        }
    
        virtual ::moltk::Aligner::QueryPosition * clone(  ) const {
            bp::override func_clone = this->get_override( "clone" );
            return func_clone(  );
        }
    
        virtual ::moltk::units::Information get_gap_extension_penalty(  ) const {
            bp::override func_get_gap_extension_penalty = this->get_override( "get_gap_extension_penalty" );
            return func_get_gap_extension_penalty(  );
        }
    
        virtual ::moltk::units::Information get_gap_open_penalty(  ) const {
            bp::override func_get_gap_open_penalty = this->get_override( "get_gap_open_penalty" );
            return func_get_gap_open_penalty(  );
        }
    
    };

    struct Scorer_wrapper : moltk::Aligner::Scorer, bp::wrapper< moltk::Aligner::Scorer > {
    
        Scorer_wrapper( )
        : moltk::Aligner::Scorer( )
          , bp::wrapper< moltk::Aligner::Scorer >(){
            // null constructor
        
        }
    
        virtual ::std::vector< moltk::Aligner::QueryPosition* > create_query_positions( ::moltk::Alignment const & arg0 ) const {
            bp::override func_create_query_positions = this->get_override( "create_query_positions" );
            return func_create_query_positions( boost::ref(arg0) );
        }
    
        virtual ::std::vector< moltk::Aligner::TargetPosition* > create_target_positions( ::moltk::Alignment const & arg0 ) const {
            bp::override func_create_target_positions = this->get_override( "create_target_positions" );
            return func_create_target_positions( boost::ref(arg0) );
        }
    
    };

    struct TargetPosition_wrapper : moltk::Aligner::TargetPosition, bp::wrapper< moltk::Aligner::TargetPosition > {
    
        TargetPosition_wrapper()
        : moltk::Aligner::TargetPosition()
          , bp::wrapper< moltk::Aligner::TargetPosition >(){
            // null constructor
            
        }
    
        virtual ::moltk::Aligner::TargetPosition * clone(  ) const {
            bp::override func_clone = this->get_override( "clone" );
            return func_clone(  );
        }
    
        virtual ::moltk::units::Information get_gap_extension_penalty(  ) const {
            bp::override func_get_gap_extension_penalty = this->get_override( "get_gap_extension_penalty" );
            return func_get_gap_extension_penalty(  );
        }
    
        virtual ::moltk::units::Information get_gap_open_penalty(  ) const {
            bp::override func_get_gap_open_penalty = this->get_override( "get_gap_open_penalty" );
            return func_get_gap_open_penalty(  );
        }
    
        virtual ::moltk::units::Information score( ::moltk::Aligner::QueryPosition const & rhs ) const {
            bp::override func_score = this->get_override( "score" );
            return func_score( boost::ref(rhs) );
        }
    
    };

    Aligner_wrapper( )
    : moltk::Aligner( )
      , bp::wrapper< moltk::Aligner >(){
        // null constructor
    
    }

};

void register_Aligner_class(){

    { //::moltk::Aligner
        typedef bp::class_< Aligner_wrapper > Aligner_exposer_t;
        Aligner_exposer_t Aligner_exposer = Aligner_exposer_t( "Aligner", "\n Aligner is the class that creates sequence or structure alignments.\n", bp::init< >() );
        bp::scope Aligner_scope( Aligner_exposer );
        bp::enum_< moltk::Aligner::Stage>("Stage")
            .value("STAGE_EMPTY", moltk::Aligner::STAGE_EMPTY)
            .value("STAGE_SCORER", moltk::Aligner::STAGE_SCORER)
            .value("STAGE_SEQUENCE", moltk::Aligner::STAGE_SEQUENCE)
            .value("STAGE_ALLOCATED", moltk::Aligner::STAGE_ALLOCATED)
            .value("STAGE_TABLE_INITIALIZED", moltk::Aligner::STAGE_TABLE_INITIALIZED)
            .value("STAGE_RECURRENCE_COMPUTED", moltk::Aligner::STAGE_RECURRENCE_COMPUTED)
            .value("STAGE_TRACED", moltk::Aligner::STAGE_TRACED)
            .export_values()
            ;
        bp::enum_< moltk::Aligner::TracebackPointer>("TracebackPointer")
            .value("TRACEBACK_UP", moltk::Aligner::TRACEBACK_UP)
            .value("TRACEBACK_UPLEFT", moltk::Aligner::TRACEBACK_UPLEFT)
            .value("TRACEBACK_LEFT", moltk::Aligner::TRACEBACK_LEFT)
            .value("TRACEBACK_DONE", moltk::Aligner::TRACEBACK_DONE)
            .value("TRACEBACK_NOT_INITIALIZED", moltk::Aligner::TRACEBACK_NOT_INITIALIZED)
            .export_values()
            ;
        bp::class_< moltk::Aligner::Cell >( "Cell", " An Aligner::Cell is one node in the dynamic programming table" )    
            .def( 
                "compute_traceback_pointer"
                , (::moltk::Aligner::TracebackPointer ( ::moltk::Aligner::Cell::* )(  ) const)( &::moltk::Aligner::Cell::compute_traceback_pointer )
                , " An Aligner::Cell is one node in the dynamic programming table" )    
            .def( 
                "compute_v"
                , (::moltk::units::Information ( ::moltk::Aligner::Cell::* )(  ) const)( &::moltk::Aligner::Cell::compute_v ) )    
            .def_readwrite( "e", &moltk::Aligner::Cell::e, " E, best score with gap in sequence 1" )    
            .def_readwrite( "f", &moltk::Aligner::Cell::f, " F, best score with gap in sequence 2" )    
            .def_readwrite( "g", &moltk::Aligner::Cell::g, " G, best ungapped score through this cell" )    
            .def_readwrite( "v", &moltk::Aligner::Cell::v, " V, best score through this cell" )    
            .def( bp::self_ns::str( bp::self ) );
        bp::class_< Aligner_wrapper::QueryPosition_wrapper, boost::noncopyable >( "QueryPosition", "\n Aligner::Position represents a special biosequence residue that knows how to score itself during alignment.\n" )    
            .def( 
                "clone"
                , bp::pure_virtual( (::moltk::Aligner::QueryPosition * ( ::moltk::Aligner::QueryPosition::* )(  ) const)(&::moltk::Aligner::QueryPosition::clone) )
                , bp::return_value_policy< bp::manage_new_object >()
                , "\n Aligner::Position represents a special biosequence residue that knows how to score itself during alignment.\n" )    
            .def( 
                "get_gap_extension_penalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::QueryPosition::* )(  ) const)(&::moltk::Aligner::QueryPosition::get_gap_extension_penalty) ) )    
            .def( 
                "get_gap_open_penalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::QueryPosition::* )(  ) const)(&::moltk::Aligner::QueryPosition::get_gap_open_penalty) ) );
        bp::class_< Aligner_wrapper::Scorer_wrapper, boost::noncopyable >( "Scorer", "\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n", bp::init< >("\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n") )    
            .def( 
                "create_query_positions"
                , bp::pure_virtual( (::std::vector< moltk::Aligner::QueryPosition* > ( ::moltk::Aligner::Scorer::* )( ::moltk::Alignment const & ) const)(&::moltk::Aligner::Scorer::create_query_positions) )
                , ( bp::arg("arg0") )
                , "\n Aligner::Scorer converts dumb sequence and structure residues into Aligner::Positions, which\n know how to quickly score themselves with other AlignerPositions.\n" )    
            .def( 
                "create_target_positions"
                , bp::pure_virtual( (::std::vector< moltk::Aligner::TargetPosition* > ( ::moltk::Aligner::Scorer::* )( ::moltk::Alignment const & ) const)(&::moltk::Aligner::Scorer::create_target_positions) )
                , ( bp::arg("arg0") ) )    
            .def( 
                "get_end_gaps_free"
                , (bool ( ::moltk::Aligner::Scorer::* )(  ) const)( &::moltk::Aligner::Scorer::get_end_gaps_free ) )    
            .def( 
                "set_end_gaps_free"
                , (void ( ::moltk::Aligner::Scorer::* )( bool ) )( &::moltk::Aligner::Scorer::set_end_gaps_free )
                , ( bp::arg("f") ) );
        bp::class_< Aligner_wrapper::TargetPosition_wrapper, boost::noncopyable >( "TargetPosition" )    
            .def( 
                "clone"
                , bp::pure_virtual( (::moltk::Aligner::TargetPosition * ( ::moltk::Aligner::TargetPosition::* )(  ) const)(&::moltk::Aligner::TargetPosition::clone) )
                , bp::return_value_policy< bp::manage_new_object >() )    
            .def( 
                "get_gap_extension_penalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::TargetPosition::* )(  ) const)(&::moltk::Aligner::TargetPosition::get_gap_extension_penalty) ) )    
            .def( 
                "get_gap_open_penalty"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::TargetPosition::* )(  ) const)(&::moltk::Aligner::TargetPosition::get_gap_open_penalty) ) )    
            .def( 
                "score"
                , bp::pure_virtual( (::moltk::units::Information ( ::moltk::Aligner::TargetPosition::* )( ::moltk::Aligner::QueryPosition const & ) const)(&::moltk::Aligner::TargetPosition::score) )
                , ( bp::arg("rhs") ) );
        { //::moltk::Aligner::align
        
            typedef ::moltk::Alignment ( ::moltk::Aligner::*align_function_type )( ::moltk::Alignment const &,::moltk::Alignment const & ) ;
            
            Aligner_exposer.def( 
                "align"
                , align_function_type( &::moltk::Aligner::align )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::moltk::Aligner::get_default_scorer
        
            typedef ::moltk::Aligner::Scorer const & ( *get_default_scorer_function_type )(  );
            
            Aligner_exposer.def( 
                "get_default_scorer"
                , get_default_scorer_function_type( &::moltk::Aligner::get_default_scorer )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::moltk::Aligner::get_end_gaps_free
        
            typedef bool ( ::moltk::Aligner::*get_end_gaps_free_function_type )(  ) const;
            
            Aligner_exposer.def( 
                "get_end_gaps_free"
                , get_end_gaps_free_function_type( &::moltk::Aligner::get_end_gaps_free ) );
        
        }
        { //::moltk::Aligner::set_end_gaps_free
        
            typedef void ( ::moltk::Aligner::*set_end_gaps_free_function_type )( bool ) ;
            
            Aligner_exposer.def( 
                "set_end_gaps_free"
                , set_end_gaps_free_function_type( &::moltk::Aligner::set_end_gaps_free )
                , ( bp::arg("f") ) );
        
        }
        Aligner_exposer.staticmethod( "get_default_scorer" );
        { //property "endGapsFree"[fget=::moltk::Aligner::get_end_gaps_free, fset=::moltk::Aligner::set_end_gaps_free]
        
            typedef bool ( ::moltk::Aligner::*fget )(  ) const;
            typedef void ( ::moltk::Aligner::*fset )( bool ) ;
            
            Aligner_exposer.add_property( 
                "endGapsFree"
                , fget( &::moltk::Aligner::get_end_gaps_free )
                , fset( &::moltk::Aligner::set_end_gaps_free ) );
        
        }
    }

}

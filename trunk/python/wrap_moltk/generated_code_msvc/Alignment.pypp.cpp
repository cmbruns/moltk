// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_moltk.hpp"
#include "alignment.pypp.hpp"

namespace bp = boost::python;

void register_Alignment_class(){

    { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >
        typedef bp::class_< moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > > Alignment_exposer_t;
        Alignment_exposer_t Alignment_exposer = Alignment_exposer_t( "Alignment", "\n Alignment represents a set of aligned macromolecule sequences and/or structures.\n", bp::init< >("\n Default constructor creates an empty Alignment_\n") );
        bp::scope Alignment_scope( Alignment_exposer );
        Alignment_exposer.def( bp::init< moltk::Biosequence const & >(( bp::arg("sequence") ), "\n Create an alignment with exactly one sequence\n") );
        bp::implicitly_convertible< moltk::Biosequence const &, moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > >();
        Alignment_exposer.def( bp::init< std::string const & >(( bp::arg("alignment_string") ), "\n Create an alignment from fasta sequences or a single sequence string\n") );
        bp::implicitly_convertible< std::string const &, moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > >();
        Alignment_exposer.def( bp::init< char const * >(( bp::arg("alignment_string") ), "\n Create an alignment from fasta sequences or a single sequence string\n") );
        bp::implicitly_convertible< char const *, moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > >();
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::align
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > ( exported_class_t::*align_function_type )( ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > const &,::moltk::EString const &,::moltk::EString const & ) const;
            
            Alignment_exposer.def( 
                "align"
                , align_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::align )
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") )
                , "\n Align two sequence alignments using a pair of precomputed EStrings.\n\n This methods is used to create the final Alignment_ after the dynamic\n programming alignment has completed.\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::append_sequence
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*append_sequence_function_type )( ::moltk::Biosequence const & ) ;
            
            Alignment_exposer.def( 
                "append_sequence"
                , append_sequence_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::append_sequence )
                , ( bp::arg("sequence") )
                , bp::return_self< >()
                , "\n Add one sequence to the alignment.  Internally, gaps will be removed and encoded into an EString.\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::fasta
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::std::string ( exported_class_t::*fasta_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "fasta"
                , fasta_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::fasta )
                , "\n Create a string with Alignment_ in fasta format\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_estring
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::EString const & ( exported_class_t::*get_estring_function_type )( ::size_t ) const;
            
            Alignment_exposer.def( 
                "get_estring"
                , get_estring_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_estring )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "\n The gapping pattern of Row index\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_number_of_columns
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::size_t ( exported_class_t::*get_number_of_columns_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "get_number_of_columns"
                , get_number_of_columns_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_number_of_columns )
                , "\n Number of columns (width) of sequence Alignment_\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_number_of_sequences
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::size_t ( exported_class_t::*get_number_of_sequences_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "get_number_of_sequences"
                , get_number_of_sequences_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_number_of_sequences )
                , "\n get_number_of_sequences() includes combined number of both sequences and structures\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_pretty_width
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef int ( exported_class_t::*get_pretty_width_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "get_pretty_width"
                , get_pretty_width_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_pretty_width ) );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_row
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::Row const & ( exported_class_t::*get_row_function_type )( int ) const;
            
            Alignment_exposer.def( 
                "get_row"
                , get_row_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_row )
                , ( bp::arg("index") )
                , bp::return_internal_reference< >()
                , "\n Access internal Alignment::Row data structure\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_row
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::Row & ( exported_class_t::*get_row_function_type )( int ) ;
            
            Alignment_exposer.def( 
                "get_row"
                , get_row_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_row )
                , ( bp::arg("index") )
                , bp::return_internal_reference< >()
                , "\n Access internal Alignment::Row data structure\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_score
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > const & ( exported_class_t::*get_score_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "get_score"
                , get_score_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_score )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "\n The precomputed total sum of pairs score of this Alignment_\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_sequence
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::BaseBiosequence const & ( exported_class_t::*get_sequence_function_type )( ::size_t ) const;
            
            Alignment_exposer.def( 
                "get_sequence"
                , get_sequence_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::get_sequence )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "\n Returns the particular sequence or structure at Row index\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::id_table
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::std::string ( exported_class_t::*id_table_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "id_table"
                , id_table_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::id_table )
                , "\n Create a string containing table of pairwise sequence identities\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_fasta
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*load_fasta_function_type )( ::std::basic_istream< char, std::char_traits< char > > & ) ;
            
            Alignment_exposer.def( 
                "load_fasta"
                , load_fasta_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_fasta )
                , ( bp::arg("input_stream") )
                , bp::return_self< >()
                , "\n Load fasta format sequences from a C++ stream\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_fasta
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*load_fasta_function_type )( ::std::string const & ) ;
            
            Alignment_exposer.def( 
                "load_fasta"
                , load_fasta_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_fasta )
                , ( bp::arg("file_name") )
                , bp::return_self< >()
                , "\n Load fasta sequences from named file\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_fasta_string
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*load_fasta_string_function_type )( ::std::string const & ) ;
            
            Alignment_exposer.def( 
                "load_fasta_string"
                , load_fasta_string_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_fasta_string )
                , ( bp::arg("fasta_string") )
                , bp::return_self< >()
                , "\n Append sequences from a string containing fasta sequences\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_string
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*load_string_function_type )( ::std::string const & ) ;
            
            Alignment_exposer.def( 
                "load_string"
                , load_string_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::load_string )
                , ( bp::arg("alignment_string") )
                , bp::return_self< >()
                , "\n Add one sequence from a single sequence string.\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::pretty
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::std::string ( exported_class_t::*pretty_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "pretty"
                , pretty_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::pretty )
                , "\n Create a string containing a pretty formatted alignment\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::repr
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::std::string ( exported_class_t::*repr_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "repr"
                , repr_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::repr )
                , "\n Low level python string representation of this Alignment_\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::set_pretty_width
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*set_pretty_width_function_type )( int ) ;
            
            Alignment_exposer.def( 
                "set_pretty_width"
                , set_pretty_width_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::set_pretty_width )
                , ( bp::arg("width") )
                , bp::return_self< >() );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::set_score
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > & ( exported_class_t::*set_score_function_type )( ::moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > const & ) ;
            
            Alignment_exposer.def( 
                "set_score"
                , set_score_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::set_score )
                , ( bp::arg("s") )
                , bp::return_self< >()
                , "\n Set the sum of pairs score for this Alignment_.  Make sure you put the correct answer!\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::shuffle
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef ::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > ( exported_class_t::*shuffle_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "shuffle"
                , shuffle_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::shuffle )
                , "\n Create a shuffled version of this alignment to help estimate significance\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_fasta
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef void ( exported_class_t::*write_fasta_function_type )( ::std::basic_ostream< char, std::char_traits< char > > & ) const;
            
            Alignment_exposer.def( 
                "write_fasta"
                , write_fasta_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_fasta )
                , ( bp::arg("output_stream") )
                , "\n Write Alignment_ in fasta format to a C++ stream\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_fasta
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef void ( exported_class_t::*write_fasta_function_type )( ::std::string const & ) const;
            
            Alignment_exposer.def( 
                "write_fasta"
                , write_fasta_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_fasta )
                , ( bp::arg("file_name") )
                , "\n Write Alignment_ in fasta format to a file\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_id_table
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef void ( exported_class_t::*write_id_table_function_type )( ::std::basic_ostream< char, std::char_traits< char > > & ) const;
            
            Alignment_exposer.def( 
                "write_id_table"
                , write_id_table_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_id_table )
                , ( bp::arg("output_stream") )
                , "\n Write table of pairwise sequence identities to a C++ stream\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_id_table
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef void ( exported_class_t::*write_id_table_function_type )( ::std::string const & ) const;
            
            Alignment_exposer.def( 
                "write_id_table"
                , write_id_table_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_id_table )
                , ( bp::arg("file_name") )
                , "\n Write table of pairwise sequence identities to a file\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_pretty
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef void ( exported_class_t::*write_pretty_function_type )( ::std::basic_ostream< char, std::char_traits< char > > & ) const;
            
            Alignment_exposer.def( 
                "write_pretty"
                , write_pretty_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_pretty )
                , ( bp::arg("output_stream") )
                , "\n Write a pretty formatted alignment to a C++ stream\n" );
        
        }
        { //::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_pretty
        
            typedef moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > > exported_class_t;
            typedef void ( exported_class_t::*write_pretty_function_type )( ::std::string const & ) const;
            
            Alignment_exposer.def( 
                "write_pretty"
                , write_pretty_function_type( &::moltk::Alignment_< moltk::units::Quantity< moltk::units::Unit< moltk::units::Dimension< 0, 0, 0, 0, 0, 0, 1 > >, double > >::write_pretty )
                , ( bp::arg("file_name") )
                , "\n Write a pretty formatted alignment to a file\n" );
        
        }
        { //property "pretty_width"[fget=::moltk::Alignment_<moltk::units::Quantity<moltk::units::Unit<moltk::units::Dimension<0, 0, 0, 0, 0, 0, 1> >, double> >::get_pretty_width, fset=::moltk::Alignment_<moltk::units::Quantity<moltk::units::Unit<moltk::units::Dimension<0, 0, 0, 0, 0, 0, 1> >, double> >::set_pretty_width]
        
            typedef moltk::Alignment_<moltk::units::Quantity<moltk::units::Unit<moltk::units::Dimension<0, 0, 0, 0, 0, 0, 1> >, double> > exported_class_t;
            
            typedef int ( exported_class_t::*fget )(  ) const;
            typedef ::moltk::Alignment_<moltk::units::Quantity<moltk::units::Unit<moltk::units::Dimension<0, 0, 0, 0, 0, 0, 1> >, double> > & ( exported_class_t::*fset )( int ) ;
            
            Alignment_exposer.add_property( 
                "pretty_width"
                , fget( &::moltk::Alignment_<moltk::units::Quantity<moltk::units::Unit<moltk::units::Dimension<0, 0, 0, 0, 0, 0, 1> >, double> >::get_pretty_width )
                , bp::make_function( 
                      fset( &::moltk::Alignment_<moltk::units::Quantity<moltk::units::Unit<moltk::units::Dimension<0, 0, 0, 0, 0, 0, 1> >, double> >::set_pretty_width )
                    , bp::return_self< >() )  );
        
        }
        Alignment_exposer.def( bp::self_ns::str( bp::self ) );
        Alignment_exposer.def("__repr__", 
                &::moltk::Alignment::repr, 
                "python low level string representation");
    }

}
